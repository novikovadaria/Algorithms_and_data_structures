/**
 * Связный список – базовая структура данных, состоящая из узлов, где каждый узел
 * содержит одну или две ссылки, который ссылаются на следующий или на
 * следующий и предыдущий узел соответственно.
 * Структурно, связные списки бывают однонаправленными – когда каждый узел
 * содержит информацию только о следующем элементе цепочки, и
 * двунаправленными – когда каждый узел ссылается на следующий и предыдущий
 * узлы. Первый узел связного списка принято называть head, т.к. именно с него
 * начинается обход. Последний элемент принято называть tail, благодаря которому
 * можно обойти связный список не только от начала, но и в обратной
 * последовательности (для двунаправленного) или просто добавить новый узел в
 * конец цепочки.С точки зрения использования – связные списки ближе всего к массивам и обычно
 * именно с массивами сравнивают данную структуру, выбирая наиболее
 * подходящую для решения задачи. Давайте проведем сравнение базовых операций,
 * общих для обоих из них.
 */

public class List {
	Node head; // Первый элемент списка
	Node tail; // Последний элемент списка


	public class Node {
		int value;
		Node next; // Следующее значение
		Node previous; // Предидущее значение
	}

// ================================================================================================

	/**
	 * Операции добавления и удаления элементов
	 * Далее следует рассмотреть операции вставки и удаления элементов. Для массива
	 * сложность и временные потери во многом будут зависеть от конкретной
	 * реализации конкретного языка программирования, но давайте рассмотрим базовый
	 * принцип. Так как все элементы массива имеют свой порядковый номер, то
	 * добавление элементов в конец массива не требует каких-то дополнительный
	 * операций – просто размерность увеличится на единицу, а за новым порядковым
	 * номером будет закреплен новый элемент. Операция удаления последнего
	 * элемента делается аналогичным образом – она не задевает другие элементы
	 * массива и не требует дополнительных операций. В данной задаче операция со
	 * связным списком будет выглядеть так же аналогично – у нас есть прямая ссылка на
	 * последний элемент и нам необходимо присоединить к нему новый.
	 * Как и в случае с массивом – сложность операции O(1).
	 * А вот операции добавления в начало или середину массива будут уже иметь свои
	 * накладные расходы, а именно – при добавлении нового элемента необходимо
	 * обновить индексы всех элементов, находящихся правее вставляемого значения,
	 * т.к. вставляемый элемент занимает индекс уже существующего объекта, а значит
	 * для всех правых элементов индекс должен увеличиться на единицу.
	 * Соответственно, чем ближе к началу вставляется новый элемент, тем более
	 * количество элементов нужно будет сдвинуть вправо, а значит сложность
	 * становится O(n). Для операции удаления ситуация аналогичной – при удалении
	 * элемента, все правые индексы уменьшаются на единицу.
	 * В связном списке же сдвигать индексы после вставки не требуется, т.к. они
	 * физически не отслеживаются и не определяются. Любая операция вставки будет
	 * похожа на операцию вставки в конец и иметь константную сложность O(1)
	 * Остается проблема поиска нужной ноды, которая, как мы говорили ранее, O(n), что
	 * суммарно дает сложность O(1) + O(n) => O(n) для всех случаев, кроме вставки в
	 * начало – мы всегда имеем ссылку на первый элемент и искать его не нужно. Для
	 * вставки в начало сложность останется O(1).
	 * Из этого можно сделать вывод, что у связного списка преимущество во вставке в
	 * первую половину своей размерности, а у массива наоборот во вторую. Вставка в
	 * конец одинаково работает для обеих структур данных. Так же различными
	 * оптимизациями алгоритмов мы можем сократить издержки для тех или иных
	 * операций для обеих структур. Например, если мы храним размер
	 * двунаправленного списка и можем точно определить, что искомый индекс
	 * находится во второй половине размерности, мы можем начать обход не с начала, а
	 * с конца списка, тем самым нивелировав разницу в сложности для вставки в первую
	 * или вторую половину списка.
	 * Также стоит учитывать поведение памяти при работе с массивом, но оно будет
	 * отличаться у разных реализаций. Например, в Java массив имеет строго
	 * фиксированную длину и, если мы хотим добавить в него элемент, чей индекс не
	 * влезает в размерность, нам нужно полностью пересоздать массив, выделив под
	 * него новое адресное, а список не имеет таких ограничений и легко дополняется
	 * новыми элементами в любой момент времени.
	 */
	public void add (int value) { // Функция вставки в конец списка
		Node node = new Node(); // Создаём новую ноду
		node.value = value; // Заполним её нужным значением
		if (head == null) { // Если список пуст
			head = node; // Создаём ссылку head указывающую на текущее значение
			tail = node; //Создаём ссылку tail указывающую на текущее значение
		} else { // Добавляем наш элемент в конец списка, добавляя связь уже предидущего tail с
			// нашим текущий
			tail.next = node; // Следующее значение от текущего tail присваивается значение node
			node.previous = tail; // Наше значение начинает ссылаться на текущий tail
			tail = node; // tail обновляем значением текущей node
		}
	}

	public void add(int value, Node node) { // Функция вставки элемента посреди списка
		Node next = node.next;
		Node newNode = new Node();
		newNode.value = value;
		node.next = newNode;
		newNode.previous = node;
		if (next == null) {
			tail = newNode;
		} else {
			next.previous = newNode;
			newNode.next = next;
		}
	}

	public void delete(Node node) { // Функция удаления элемента из списка
		Node previous = node.previous;
		Node next = node.next;
		// Случай с удалением элемента head
		if (previous == null) {
			next.previous = null; // Обнуляем текущий head
			head = next; // Кладём в head значение следующее за текущим head
		} else {
			// Случай с удалением элемента tail
			if (next == null) {
				previous.next = null; // Обнуляем текущий tail
				tail = previous; // Кладём в tail значение предидущее перед текущим tail
			} else {
				// Случай с удалением элемента посреди списка
				previous.next = next;
				next.previous = previous;
			}
		}
	}

// ================================================================================================

	/**
	 * Поиск элементов в связном списке
	 * Первая и самая базовая операция – это операция поиска значений. Для массива
	 * существует 2 основных метода – метод перебора (для любых массивов) и бинарный
	 * поиск для отсортированных массивов. Метод перебора прекрасно подходит и для
	 * связного списка, только перебирать мы будем не индексы, а непосредственно узлы.
	 * Как несложно догадаться, подобный перебор имеет точно такую же сложность, как
	 * и у массива – O(n).
	 * А вот если посмотреть в сторону бинарного поиска, который давал значительно
	 * большую производительность – O(log n), то все становится не так хорошо. Большая
	 * часть алгоритмов, использующихся с массивом, завязана на операции с индексом
	 * элементов и бинарный поиск не исключение. Вспомним, что операция обращения
	 * по индексу для элементов массива имеет сложность O(1), т.к. система всегда точно
	 * знает, где именно в памяти какой элемент располагается. Это базовое свойство
	 * массива, отраженное в способе хранения данных в памяти компьютера. Но если мы
	 * посмотрим на наш связный список, то увидим, что у экземпляров Node нет никакого
	 * упоминания индекса, т.е. абсолютного местоположения в структуре. Есть только
	 * относительные маркеры – ссылки на предыдущий и следующий элементы. Зная
	 * это, мы также можем найти элемент нужного индекса. Базовый алгоритм поиска
	 * будет выглядеть следующим образом:
	 * Мы берем первую ноду в списке и начинаем по очереди перебирать значения, пока
	 * не найдем требуемый узел, либо список не закончится. Как несложно догадаться,
	 * подобный поиск будет иметь сложность O(n). А это значит, что все плюсы бинарного
	 * поиска, связанные с пропуском элементов, не сработают для связного списка –
	 * перемещение индекса влево или вправо после сравнения снова потребует
	 * совершить перебор элементов до нужного индекса, тем самым количество
	 * операций будет от n/2 (искомый элемент является серединой списка и первым
	 * кандидатом на проверку при алгоритме бинарного поиска) до n (элемент первый
	 * или последний в списке), что дает сложность поиска все те же O(n), что и в простом
	 * переборе.
	 */
	public Node find(int value) {
		Node currentNode = head; // Переменная currentNode начинается с head
		while (currentNode != null) { // Цикл пока текущая Node не равна null, тоесть пока в
			// текущей Node есть значение.
			if (currentNode.value == value) { // Если значение поиска равно текущему значению
				return currentNode; // возвращаем текущее значение
			}
			currentNode = currentNode.next; // Если условие не выполнено, то переходим к
			// следующему значению в списке
		}
		return null; // Если значение не найдено, то возвращаем null
	}

// ================================================================================================

	/**
	 * Разворот связного списка
	 * Для связного списка также существуют специфические задачи – например,
	 * разворот. Разворотом называется операция, когда последний элемент становится
	 * первым, предпоследний вторым и т.д.
	 * Когда речь идет про алгоритмы разворота, то оценивать сложность с точки зрения
	 * количества операций смысла не имеет – все равно тем или иным образом нам
	 * придется обратиться к каждому из элементов списка, а значит получить сложность
	 * O(n). А вот количество памяти, которое придется затратить будет иметь значение.
	 * Например, самый просто способ получить развернутый список (если мы говорим
	 * про двунаправленный список), это создать новый экземпляр и заполнить его,
	 * прочитав исходный список с конца. Но создание полностью нового экземпляра
	 * списка со всеми значениями потребует O(n) памяти, т.к. для каждого узла придется
	 * создать копию в новом объекте. Для больших объектов это может стать проблемой.
	 * Давайте разберем вариант, при котором расход памяти будет меньше, а именно
	 * O(1), что более оптимально.
	 * На самом деле нам не имеет смысл создавать новый список, если нам нужно
	 * развернуть существующий. Каждый узел списка всегда хранит в себе ссылки на
	 * соседние элементы, а значит их нужно просто поменять местами, что последний
	 * элемент стал первым. Проще всего это продемонстрировать на однонаправленном
	 * списке.
	 * А значит алгоритм будет представлять из себя обычный перебор, где мы меняем
	 * ссылки местами.
	 * Таким образом нам требуется только 1 дополнительная переменная в памяти для
	 * хранения значения во время замены элементов местами, что дает константную
	 * сложность O(1).
	 */
	public void revert() {
		Node currentNode = head;
		while (currentNode != null) {
			Node next = currentNode.next;
			Node previous = currentNode.previous;
			currentNode.next = previous;
			currentNode.previous = next;
			if (previous == null) {
				tail = currentNode;
			}
			if (next == null) {
				head = currentNode;
			}
			currentNode = next;
		}
	}



// ================================================================================================

	// Метод добавления в начало односвязного списка
	public void pushOneLink(int value) {
		Node node = new Node();
		node.value = value;
		node.next = head;
		head = node;
	}

	// Метод извлечения из начала односвязного списка
	public Integer pop() {
		Integer result = null;
		if (head != null) {
			result = head.value;
			head = head.next;
		}
		return result;
	}

// ================================================================================================

	// Метод добавления в начало многосвязного списка
	public void pushMultyLink(int value) {
		Node node = new Node();
		node.value = value;
		node.next = head;
		head.previous = node;
		head = node;
	}

	// Метод извлечения с конца многосвязного списка.
	public Integer peek() {
		Integer result = null;
		if (tail != null) {
			result = tail.value;
			tail.previous.next = null; // для предидущего элемента он станет последним
			tail = tail.previous; // и сам tail меняем на предидущий элемент
		}
		return result;
	}
}