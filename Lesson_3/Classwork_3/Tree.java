import java.util.ArrayList;
import java.util.List;

/**
 * Дерево – это структура данных, эмулирующая древовидную структуру в виде
 * набора связанных узлов. Дерево является частным случае графа, в котором
 * отсутствуют циклические связи. Дерево состоит из узлов, связанных между собой
 * ребрами по принципу родитель-ребенок.
 * Один узел может содержать в себе любое количество детей, но у любого ребенка
 * может быть только один родитель. Самый верхний узел, не имеющий родителя,
 * называется корнем дерева, а узлы, не имеющие детей – листьями.
 * С точки зрения реализации в языках программирования, дерево очень похоже на
 * реализацию связного списка, за тем исключением, что каждый из узлов может
 * ссылаться не на один, а на любое количество дочерних элементов.
 * Использование древовидной структуры позволяет обрабатывать данные,
 * требующие иерархического отношения друг к другу. Простой пример – дерево
 * файлов в компьютере, где каждый узел с детьми – это папка, а каждый лист – файл
 * или пустая папка.
 */
public class Tree {
	Node root; // корень дерева

	public class Node {
		int value;
		List<Node> children;
	}

	// =============================================================================================

	/**
	 * Проверка существования нужного значения поиска.
	 */
	public boolean exist(int value) {
		if (root != null) { // проверка на то что у нас вообще есть какие либо данные
			Node node = recursionFind(root, value); // запускаем поиск от корня дерева
			// и передаём значение поиска
			if (node != null) { // если значение найдено = true , если нет = false
				return true;
			}
		}
		return false;
	}

	// =============================================================================================

	/**
	 * Рекурсивный метод поиска значения с погружением в глубину дерева.
	 * Самым простым с точки зрения обхода, является обход в глубину. Это рекурсивный
	 * подход к перебору всех значений в дереве, построенный на вызове всех доступных
	 * детей для каждого узла. Таким образом максимальная глубина рекурсии будет
	 * равна максимальной глубине дерева, а порядок будет идти сверху-вниз и
	 * слева-направо.
	 * Чаще всего используется именно обход в глубину, т.к. он прост в реализации и не
	 * требует слишком большого количества ресурсов на исполнение.
	 */
	private Node recursionFind(Node node, int value) {
		if (node.value == value) { // проверяем текущую ноду, если она содержит нужное значение
			return node; // то возвращаем значение текущей ноды
		} else { // если нет, то проваливаемся глубже
			for (Node child : node.children) { // для каждого "ребенка"
				Node result = recursionFind(child, value); // рекурсивно вызываем метод find
				if (result != null) { // если в переменную result попадает нужное значение
					return result; // то возвращаем это значение
				}
			}
		}
		return null; // ну а если ничего не нашли то возвращаем null
	}

	// =============================================================================================

	/**
	 * Цикличный метод обхода дерева в ширину с поиском значения на каждом уровне дерева.
	 * Обход в ширину предполагает, что мы не обрабатываем детей до тех пор, пока все
	 * родителя одного уровня не были обработаны. Давайте рассмотрим пример, при
	 * котором мы хотим получить все элементы дерева в виде списка.
	 * Данный алгоритм не вызывает рекурсию, но в основном используется не для
	 * поиска, а для массовых операций со значениями в дереве.
	 */
	private Node cycleFind(int value) {
		List<Node> line = new ArrayList<>(); // список текущей линии обхода
		line.add(root); // добавляем root для начала поиска с него
		while (line.size() > 0) { // до тех пор, пока в дереве существуют "дети"
			List<Node> nextLine = new ArrayList<>(); // заводим новый список
			for (Node node : line) { // перебираем каждый элемент в линии поиска
				if (node.value == value) { // если нужное значение найдено
					return node; // возвращаем значение
				}
				// если нет, тогда добавляем в nextLine всех "детей" формируя новый список поиска.
				nextLine.addAll(node.children);
			}
			line = nextLine; //если прошлись по текущей линии дерева и ничего не нашли, то
			// обновляем линию переходим к поиску
		}
		return null;
	}
}
